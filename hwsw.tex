% Section 5 in file hwsw.tex

% Section 5.1
\subsection{Radio Transceiver}
For the radio transceiver of WHCS the chip that we decided to use is Nordic
Semiconductor{}'s NRF24L01+. This chip meets all the requirements that we set
for our radio transceiver. The NRF is also a very popular chip that is easy to
find and rarely out of stock. This is a benefit to the manufacturability of
WHCS because NRFs are cheap and easy to buy in bulk. Alternatively we could
have chosen to use an XBee radio device which implements the zigbee 802.15.4
IEEE standard, however we did not see the need for this. XBee devices are also
more expensive than the NRF chips that we have decided to utilize.

% Section 5.1.1
\subsubsection{Operating Principles and Usability of NRF24L01+}
The NRF24L01+ is a radio transceiver that operates in the ISM (Industrial,
Scientific, and Medical) radio band. The range of channels for the NRF is
2.4GHz to 2.527 GHz, however because the designated ISM band that we are using
only ranges from 2.4GHz to 2.5GHz we will not be able to use all of the NRF{}'s
available channels. With the NRF we are capable of sending payloads with a
maximum size of 32 bytes per transmission from module to module. We will be
able to change the data length from 1 to 32 bytes in order to find the optimal
mix between reliability and speed. Every NRF chip has the ability to
simultaneously store 1 transmission address and 6 receiving addresses. The
first receiving address is utilized if the auto{}-acknowledgement feature is
enabled, so effectively there are 5 receiving addresses.  This capability gives
us flexibility for implementing our network because we make decisions such as
having a dedicated address to each node in the network as well as an address
for broadcasts of certain types. The addresses of the NRF are 5 bytes wide so
we will be able to have many NRF modules within the network. A very useful
feature of the NRF is the ability to enable auto{}-acknowledgement. When this
feature is activated the receipt of a transmission from one NRF to the other is
auto{}-acked without the need from any upper level software. This simplifies
the work necessary for creating our own network of NRF chips. We will be able
to confirm the receipt of data therefore increasing reliability.  This
auto{}-ack also allows the NRF to perform retries up to a given limit, so just
in case there is noise during the transmission the NRF will repeatedly try to
transmit again. The NRF also allows for low power mode and long range mode.
For WHCS we will be able to tweak whether or not to use long range mode or not
depending on the performance of the system within its environment.

The NRF requires 3.3v of electricity to operate so all parts of WHCS will
require a 3.3v line. The datasheet lists the current consumption while in
receive mode as 18mA. This will be the most common mode for the NRF chips
present in WHCS so they can be ready to receive commands at any time. The chip
receives commands from a microcontroller through SPI (Serial Peripheral
Interface). This is great because the NRF design philosophy fits perfectly with
our microcontroller based base station and control modules. Beside the standard
MOSI, MISO, and SCK for SPI, the NRF also has a csn pin for telling it to
receive commands, ce pin for telling to to transmit or receive at that moment,
and an interrupt pin for notifying the microcontroller of important situations.
The csn pin will allow the SPI bus to be shared with other components such as
the LCD being used for the base station. The interrupt wire pin can be
monitored in order to listen for data received, data sent, and data failed to
send notifications. In total the NRF will take up 6 pins whilst three of the
pins will be shareable with other SPI components.

% Section 5.1.2
\subsubsection{Driver Use Case}
The NRF chip that we have decided to use for communication in WHCS will need to
have a driver written for it. This will help keep the way we interface with the
NRF consistent and will provide clean code. All of the network code that we
write for the base station and the control modules will be relying on the
integrity of the NRF driver that we write.  The driver provides the foundation
and if it is not reliable then none of the code we write for our system will be
reliable. The focus for the development of the NRF driver is elegance. We want
everything the NRF driver offers to be simple yet accomplish everything
necessary. We have developed the use case diagram pictured in
\autoref{fig:nrf-usecase-diagram} as a guideline for the development of the NRF
driver. The NRF driver should provide the functionality included in the use
case diagram in an easy to use format.  These will be the most common uses of
the NRF.

\ucfgfx{fig:nrf-usecase-diagram}{a51-img001.png}{NRF Driver Use-case Diagram}

The core use of the NRF driver is transmitting and receiving payloads. Every
other use case is a supporting role for the final goal of transmission. The
basis of the driver will be reading and writing registers. Everything will
build off of this capability, especially reading and writing the payload for
transmission. Other use cases such as changing power mode, checking the status
of the chip, and changing from a transmitter to a receiver will be special
forms of writing to a register. Thus reading and writing to registers is a use
of the driver, however it will be abstracted in a way that provides ease of
use. A user of the NRF driver will spend most of the time setting addresses,
writing payloads, transmitting payloads, and analyzing interrupts. These use
cases need to be implemented perfectly to provide a strong foundation for the
networking of WHCS.

% Section 5.1.3
\subsubsection{Driver Class Diagram}
It was decided that the best design approach for implementing the NRF driver
was as a class in C++. We will be using atmega microcontrollers in WHCS so C++
is supported as a development language. Using C++ allows us to create a class
that can leverage object oriented programming techniques such as encapsulation.
The class diagram for the driver is shown in \autoref{fig:nrf-class-diagram}.
Primitive functions such as ReadByte and WriteByte can be hidden from a user
while PowerUp will be exposed as a public function. Using C++ also gives us the
ability to use a constructor when using the WHCSNrf class, and in this
constructor we can assign the only thing varying between uses of the NRF, the
chip enable pin and the chip select not pin. Assigning the ce pin and the csn
pin are the first step of using the NRF driver. Any communication between the
microcontroller and the NRF will rely on the proper assignment of these pins.

\ucfgfx{fig:nrf-class-diagram}{a51-img002.png}{NRF Class Diagram}

Usage of the NRF driver will involve first constructing the class by telling
the microcontroller which pins the NRF is connected to. Then the user will be
doing everything necessary to customize the way that data is transmitted and
received. The driver exposes the common settings in an easy to access manner.
Enabling things such as auto{}-acknowledgement and the number of retries for
the transceiver can be done with the call of a function with simple parameters.
Setting the address for receiving and transmitting data can be done in one line
of code. The SetTxAddr function will be one of the most utilized function for
an NRF involved in a network constantly sending payloads to other chips. A
typical use will involve powering up the NRF with the PowerUp call, setting the
transmission address, writing a payload, and then transmitting a payload. With
this driver, the user does not need to know the registers involved with the
NRF. The hardware interactions with the chip are all abstracted away.

% Section 5.1.4
\subsubsection{Network Library}
\label{sec:network-library}
\todo{3 pages}

% Section 5.2
\subsection{Microcontrollers}
\todo{Talk about pin count and having to disable the JTAG fuses to get access to those pins}
\todo{Talk about the speed grade for the CPU and why a higher grade would be faster}


% Section 5.2.1
\subsubsection{Development Environment}

% Section 5.2.2
\subsubsection{Programming}

% Section 5.2.3
\subsubsection{Control Module}

% Section 5.2.4
\subsubsection{Base Station}

% Section 5.2.5
\subsubsection{External Oscillator}

% Section 5.3
\subsection{BlueTooth Chip}

% Section 5.3.1
\subsubsection{RN-41}

% Section 5.3.2
\subsubsection{HC-05}

% Section 5.4
\subsection{LCD}
\todo{whole section}
Being able to interface with WHCS like a normal wall thermostat is one of our
project goals. Having a centralized display that can quickly display the most
important information for homeowners would be step up from traditional ``dumb''
thermostats. With a simple LCD combined with a touchscreen, users now have a
way to control and query their home without having to find their phone.

For our LCD touchscreen, we have choosen Adafruit's 2.8" TFT\footnotemark with
resistive touch, which uses the \href{}{ILI9341 chipset}. There are
\href{https://github.com/adafruit/Adafruit_ILI9341/tree/master/examples}{plenty
of usage examples} and Adafruit's
\href{https://learn.adafruit.com/adafruit-2-dot-8-color-tft-touchscreen-breakout-v2}{excellent
technical documentation} combined with their
\href{https://github.com/adafruit/Adafruit_ILI9341}{libraries} guarantee that
integrating this in to our design will be straight forward. One issue with this
solution is with the ILI9341 driver code: it was written to target the Arduino
platform. Now, the Arduino platform is fairly close to bare AVR, minus the
remapped pin numbers and some support libraries. Porting Adafruit's library
would be a feasible solution or writing a specific minimal driver would suffice
as well.

\footnotetext{\url{https://www.adafruit.com/products/1770}}

% Section 5.4.1
\subsubsection{Capabilities}
\todo{1 page}

% Section 5.4.2
\subsubsection{Driver}
\todo{2 page}

% Section 5.4.3
\subsubsection{Touchscreen}
\todo{1 page}

X+, X-, Y+, Y-

% Section 5.4.4
\subsubsection{UI Library}
\todo{2 page}

% Section 5.5
\subsection{Android Application}

% Section 5.5.1
\subsubsection{Development Environment}

% Section 5.5.2
\subsubsection{Speech Recognition}

% Section 5.5.3
\subsubsection{BlueTooth Library}

% Section 5.5.4
\subsubsection{GUI Philosophy}

% Section 5.5.5
\subsubsection{Use Case Diagram}

% Section 5.5.6
\subsubsection{BlueTooth Listener Class}

% Section 5.5.7
\subsubsection{Creating Endpoint Groups}

% Section 5.6
\subsection{Power Hardware}

% Section 5.6.1
\subsubsection{Design Summary}

% Section 5.6.2
\subsubsection{Regulators vs DC to DC Converters}

% Section 5.6.3
\subsubsection{Backup Battery Configuration}

% Section 5.6.4
\subsubsection{Transformer Choice}

% Section 5.6.5
\subsubsection{Power Consumption}

% Section 5.6.6
\subsubsection{Isolation}

% Section 5.6.7
\subsubsection{Power Through Hole Board}

% Section 5.6.8
\subsubsection{Schematic}

% Section 5.7
\subsection{Base Station}
\todo{whole section except sch breakdown}

% Section 5.7.1
\subsubsection{Software Flowchart}

% Section 5.7.2
\subsubsection{Control Module Data Structures}

% Section 5.7.3
\subsubsection{Networking State Machine}

% Section 5.7.4
\subsubsection{Associating With Base Station}

% Section 5.7.5
\subsubsection{Schematic Breakdown}

% Section 5.8
\subsection{Control Module}
\todo{whole section except schematic breakdown}

% Section 5.8.1
\subsubsection{Software Flowchart}

% Section 5.8.2
\subsubsection{Schematic Breakdown}

% Section 5.8.3
\subsubsection{High-Voltage Control}

% Section 5.8.4
\subsubsection{Electronic Strike}
\label{sec:electronic-strike}

% Section 5.8.4.1
\paragraph{Normally Open or Normally Closed}

% Section 5.8.4.2
\paragraph{Strike vs Deadbolt}

% Section 5.8.5
\subsubsection{Sensor Collection}

% Section 5.8.6
\subsubsection{Light Control}

